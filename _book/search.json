[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Advanced Statistics 25/26",
    "section": "",
    "text": "Welcome to Advanced Statistics\nThis page contains the core materials for the module. Each week, we will typically complete one tutorial and one worksheet. If there are slides associated with the workshop, these will be to the respective on Canvas &gt; Advanced Statistics &gt; Units &gt; Week X.",
    "crumbs": [
      "Welcome to Advanced Statistics"
    ]
  },
  {
    "objectID": "index.html#using-posit-cloud",
    "href": "index.html#using-posit-cloud",
    "title": "Advanced Statistics 25/26",
    "section": "Using Posit Cloud",
    "text": "Using Posit Cloud\nYou can find the information on joining the Advanced Statistics Posit Cloud workspace on Canvas by going to Module Information &gt; Module materials .\nEach new project you create will have two folders:\n\nquarto: containing a file for making notes and a file for completing the worksheet\ndata: empty by default. For each tutorial, you will need to download the data from this page and upload it into this folder.\n\n\nDownloading and uploading datasets\nEach tutorial contains a link to the dataset under The data section. It might look something like this:\n\n… the data for this scenario are stored in the file climbing_data.csv\n\nTo download the data:\n\nRight-click on the hyperlink (or tap with two fingers)\nFrom the pop-up menu, select “Save as” or an equivalent, like “Save linked file as” or “Save link as”\nYour browser will then either ask you to choose which folder you want to store the file in, or it will go automatically into downloads.\n\nTo upload the data to Posit:\n\nOpen a project on Posit\nNavigate to the data folder under “Files” (bottom right pane)\nSelect “Upload”. Navigate to the folder with the downloaded file and select it.\n\nOnce the data are in the correct folder, the code from the tutorial will work without any alterations.",
    "crumbs": [
      "Welcome to Advanced Statistics"
    ]
  },
  {
    "objectID": "index.html#tutorials-and-suggested-workflow",
    "href": "index.html#tutorials-and-suggested-workflow",
    "title": "Advanced Statistics 25/26",
    "section": "Tutorials and suggested workflow",
    "text": "Tutorials and suggested workflow\nDuring the first half of the workshop, we will work through the main parts of the tutorial together - I will demonstrate how to approach tasks and highlight what things to look out for. The second part of the workshop is dedicated to independent work, in which you’re expected to complete the following exercises:\n\nThe What does this code do? section\nThe Worksheet\n\nboth of which will be based on the tutorial we’ve just covered. How exactly you use these tutorials will depend on how you prefer to learn. Here are some options:\nOption 1: Prepare before the session\n\nWork through the tutorial before the session, trying out different bits of code in the Quarto file on Posit Cloud\nListen during the demonstration to check your your understanding, perhaps make some additional notes.\nJump straight into working on the independent exercises. Ask if you’re not sure about anything.\n\nOption 2: Learn as you go\n\nTreat the workshops as your first point of contact with the new material.\nListen during the demonstration to take in new information.\nDuring the independent work, revisit any parts of the tutorial which were unclear during the demonstration. Then use the tutorial to complete the worksheet. Ask if you’re not sure about anything.\n\nOption 3: The middle ground\n\nBefore the workshop, prepare a quarto file that contains all the code from the tutorial for that week - you don’t necessarily need to read the whole tutorial to do this.\nDuring the demonstration, listen, run the code along with the tutor and make notes.\nJump straight into working on the independent exercises. Revisit any part of the tutorial that were unclear during the demonstration. Ask if you’re not sure about anything.\n\nOr any combination of the three. The point is, you can either use the tutorials as a reference point or as a way to prepare for the session - whatever you choose to do is up to you, as long as you’re able to complete the independent exercises each week.\nCan I complete the exercises at home?\nYes, there’s nothing stopping you from doing so. The main benefit of working from them in the session is that you’ll be able to talk to your peers and get feedback directly from the tutor.",
    "crumbs": [
      "Welcome to Advanced Statistics"
    ]
  },
  {
    "objectID": "01a_gzlms_skewed.html",
    "href": "01a_gzlms_skewed.html",
    "title": "1  Modelling skewness",
    "section": "",
    "text": "1.1 Gamma models\nGamma models are used for modelling right skewed distributions. That is, skewed distributions with the tail on the right side. Unlike Gaussian distributions, which are defined by the mean and the standard deviation, Gamma distributions are defined by shape and scale parameters. These parameters define the extent of skewness and the length of tails, but how shape and scale work together to create a distribution is a little less intuitive than mean and SD in a normal distribution. So let’s have a look:\n1gamma_dist &lt;- rgamma(n = 10000, shape = 1, scale = 1)\n\n2ggplot2::ggplot(data = NULL, aes(x = gamma_dist)) +\n3  geom_density()\n\n\n1\n\nGenerate a gamma distribution. We’re generating 1000 data points n = 1000. We’re also setting both the shape and scale to be equal to 1. Save the result to the object called gamma_dist\n\n2\n\nInitialise a ggplot. gamma_dist is just a vector of numbers, not a dataset. So we set the data argument to NULL, and we use gamma_dist on the x axis.\n\n3\n\nAdd a density plot to show the distribution.\nShape and scale of 1 generate a very skewed distribution with a long right tail. How about changing the scale to 2?\ngamma_dist &lt;- rgamma(n = 10000, shape = 1, scale = 2)\n\nggplot2::ggplot(data = NULL, aes(x = gamma_dist)) +\n  geom_density()\nIf we change the scale, the tail becomes even longer and the distribution is more pointy. What if we change scale back to 1 and this time set shape to 2?\ngamma_dist &lt;- rgamma(n = 10000, shape = 2, scale = 1)\n\nggplot2::ggplot(data = NULL, aes(x = gamma_dist)) +\n  geom_density()\nThe mass of the distribution has slightly shifted to the right. There is a lot of flexibility in the kinds of distributions that can be modelled under the Gamma family, which makes it incredibly useful and broadly applicable.",
    "crumbs": [
      "Generalised Linear Models",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Modelling skewness</span>"
    ]
  },
  {
    "objectID": "01a_gzlms_skewed.html#gamma-models",
    "href": "01a_gzlms_skewed.html#gamma-models",
    "title": "1  Modelling skewness",
    "section": "",
    "text": "Data visualisation\nWe’re going to recreate Figure 1, but this time, we’re also adding the prediction line for a would-be Gamma model. We do so by including the following line in the ggplot”\n\n... + \nstat_smooth(method = \"glm\", colour = \"darkorange\", fill = \"darkorange\", \n            method.args = list(family = \"Gamma\")) + \n...\n\n\nmethod = \"glm\": we change this from “lm” to indicate that we’re fitting a generalised linear model, not a general linear model.\ncolour = \"darkorange\", fill = \"darkorange\": these are the same as before, we’re just changing the colour code\nlinetype = \"dashed\": optional argument to differentiate the type of the line. This is only needed if we’re showing multiple lines on the plot.\nmethod.args = list(family = \"Gamma\") - these are the arguments that we want to specify for the method. We can use multiple arguments here, so we wrap everything in the list function. Inside the list function, we specify that the family we’re using to construct the line is \"Gamma\".\n\n\nbelay_tib |&gt; \n  ggplot2::ggplot(data = _, aes(x = climbing_exp, y = reaction_time)) + \n  geom_point(alpha = 0.7, colour = \"yellowgreen\") + \n  stat_smooth(method = \"lm\", colour = \"steelblue\", fill = \"steelblue\") + \n  stat_smooth(method = \"glm\", \n              colour = \"darkorange\", fill = \"darkorange\", \n              linetype = \"dashed\",\n              method.args = list(family = \"Gamma\")) + \n  coord_cartesian(xlim = c(0, 10), ylim = c(0, 1030.5)) + \n  labs(x = \"Belayer's climbing experience (in years)\", y = \"Reaction time (ms) to break the fall\") + \n  theme_light() \n\n\n\n\n\n\n\nFigure 1.1\n\n\n\n\n\nWe’re keeping the original straight line on the plot just for comparison but though we wouldn’t usually do this if we’re just fitting a Gamma model.\nTwo things to note here:\n\nPrediction: The dashed line (the Gamma model) is better able to predict the cases on the left end of the distribution by tilting upwards. Likewise, the line becomes less steep towards the right end, suggesting it won’t go on downwards forever.\nNon-linear relationship: The line is not straight - the rate of change (the slope) is different in different sections of the plot. This could be a problem for a General Linear Model, but Generalised Linear Models have an in-built way way of modelling this.\n\n\n\nLink functions\nGaussian models assume that the conditional distribution of the outcome is normal. Normal distribution is unbound - it ranges from \\(-\\infty\\) to \\(+\\infty\\) , which makes it possible and convenient to fit straight lines that also go from \\(-\\infty\\) to \\(+\\infty\\) (see section Going Beyond the data). The slope of this line is fixed, which means that we’re able to describe the relationship between two variables with just one parameter estimate. The problem is that many distributions we encounter in real life are bound on one end or both and might not be symetrical. For example the Gamma distribution can only ever contain positive values (i.e. values greater than 0), so fitting a line that extends to infinity just won’t do. But we still want a single parameter with which to test our hypothesis.\nEnter link functions. They are functions that we apply to the conditional outcome distribution so that we can express the relationship between the outcome and the predictor as a linear term, such that:\n\\[\ng\\{E(Y_i)\\} = \\beta_0 + \\beta_1X_i\n\\]\nHere, the expected1 conditional value of the outcome \\(E(Y_i)\\) at given value of the predictor X is transformed by some (for now unspecified) function \\(g\\) . Because of this transformation, a linear combination of the intercept \\(\\beta_0\\) , the slope \\(\\beta_1\\) and the value of the predictor \\(X\\) can be used to make predictions.\n\n\n\n\n\n\nWatch out! We are not transforming the outcome.\n\n\n\n\n\nSometimes researchers will attempt to transform the raw outcome variable in an attempt to “fix” skewness and then fit a regular GLM (using OLS estimation). In effect, they move the transformation to an earlier step:\n\\[\nE(g(Y_i)) = \\beta_0 + \\beta_1X_i\n\\]\nso that the expected value of the transformed outcome \\(Y_i\\) can be predicted from the linear term. This is a bad idea an not what we’re doing when we’re applying a link function. The link function is applied to the expected values, not to the raw variable. An OLS model fitted to a transformed variable will not only give inaccurate parameter estimates, but the estimates themselves will be uninterpretable with reference to the variable we originally collected.\nThe stats behind GzLM are complicated. Conditional distributions are unintuitive to think about and link functions can be confusing. It’s normal to find this stuff difficult. If you only remember one thing from this whole section, then please let it be this:\nGeneralised Linear Models need to apply a transformation somewhere in the process under the hood to make non-linear prediction possible. This is not the same as transforming the raw variables and then fitting a simple linear model.\n\n\n\n\nCanonical link functions\nDifferent distributions are associated with different link functions that will achieve the linearising transformation described above. We call them “canonical link functions”. We’ll introduce relevant link functions as we learn about different models. For Gamma models, the link function that we need to apply is the logarithm, or the “log” function.\n\n\n\nFit the model\nLet’s fit our model using the glm function, which we introduced in the section Fitting GzLM in R.\n\nbelay_gamma &lt;- glm(\n  reaction_time ~ assisted_break + climbing_exp + distracted + fall_m,\n  family = Gamma(link = \"log\"), \n  data = belay_tib \n)\n\nThe part of the code that does all the heavy lifting is this: family = Gamma(link = \"log\") in which we’re asking the function to use the Gamma family and apply the log link function.\n\n\nCheck model assumptions\nWe can use the same function as before to check for model assumptions. For Gamma models, the output is going to be very similar, but the underlying calculations differ in some instances.\n\nbelay_gamma |&gt; check_model()\n\n\n\n\n\n\n\nFigure 1.2\n\n\n\n\n\n\nPosterior predictive checks - this is an obvious indicator that the Gamma distribution was a good choice. The simulated predicted values match the observed data much better than they did for an OLS model (Figure 1).\nHomogeneity of variance - this plot can be interpreted in the same way as the plot for OLS models. That is, we’re hoping to not see any patterns or curvature, which appears to be the case. The residuals we see plotted, however, are so called “Pearson residuals”, which can be thought of as the differences between the predicted and the observed values adjusted for the variance - the function for variance will differ depending on the distribution we’re working with.\nInfluential observations - there don’t appear to be any influential observations based on the Cook’s distances or Leverage values. Like the previous plot, this plot also shows the Pearson residuals.\nCollinearity - All VIF values are below 10, suggesting no issues with multi-collinearity.\nUniformity of residuals - obviously, we’re not expecting the residuals to be normally distributed, so that’s not what we’re checking here. What we are checking is whether the residuals follow a uniform distribution - if the the dots are following the diagonal line closely, the residuals are uniformly distributed. The residuals on this plot are, again, not the differences between the predicted and the observed values, nor they are Pearson residuals. They are simulated residuals based on making repeated predictions from our model (similar to bootstrapping)\n\nThese assumptions are not assumptions in the same sense as they are for OLS models. In OLS models, if normality or heteroscedasticy are violated, we cannot trust the p-values and confidence intervals because of the maths underlying the standard errors. For GzLM, the underlying logic is a little different. Gamma models do not assume homoscedasticity - quite the opposite. They also don’t assume a uniform distribution for the residuals. But if the specific type of residuals we extracted is uniform, it’s a signal that the model is well specified. All of the model checks above are just that - they check whether the model we have assumed (i.e. the Gamma model) makes sense given the data. For all intents and purposes we do need to check them and take them as seriously as “classic” assumptions, but the reasons for checking are different.\n\n\n\n\n\n\nThe depths of residual hell (optional section that will make you sad)\n\n\n\n\n\nIf the section above reads a bit like “trust me bro”, blame the check_model function (that’s what I do anyway) which hides all of the complicated explanations in exchange for convenience and a fraction of your soul every time you use it. This section explains some of the weirdness with the different types of residuals. You can skip it if you have better things to do. If you don’t have better things to do, I suggest picking up embroidery or climbing.\nStill persisting? Very well. Let’s start with the more complicated ones, which is the uniformity of residuals. Like we said above, GzLM doesn’t assume a uniform distribution of the residuals, and it doesn’t assume normal distribution of the residuals. How about Gamma-distributed residuals for Gamma models? Also no - recall that Gamma distribution can only take on positive values. Residuals represent the error in the model prediction, and this error can be positive or negative so a Gamma distribution is impossible for residuals, unless we’ve really misspecified the model.\nIn a well specified model, roughly about a half of the residuals will be positive a half will be negative (or a half of the points will be above the line and half will be below the line, as in Figure 1.1). This of course doesn’t allow us to place any expectations on the shape of the distribution other than that it will be symmetrical and centred around zero.\nThe check for uniform residuals turbo-charges this idea by running simulations based on our model. R has an in-built simulate function that can be applied to any compatible model to generate predictions. For example:\n\nsimulated_predictions &lt;- simulate(belay_gamma, nsim = 10)\nsimulated_predictions\n\n\n\n\n\n\n\nThis will take our model 10 times and create 10 sets of new predictions for the value of the outcome (reaction time) based on the model we fitted. Were are the values being draw from? We we request a standard non-easystats-y summary of our model we get this:\n\nbelay_gamma |&gt; \n  summary()\n\n\nCall:\nglm(formula = reaction_time ~ assisted_break + climbing_exp + \n    distracted + fall_m, family = Gamma(link = \"log\"), data = belay_tib)\n\nCoefficients:\n               Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)     6.62505    0.09243  71.674  &lt; 2e-16 ***\nassisted_break -0.06913    0.03094  -2.234 0.026965 *  \nclimbing_exp   -0.11136    0.01052 -10.591  &lt; 2e-16 ***\ndistracted      0.13151    0.03063   4.294 3.18e-05 ***\nfall_m          0.14996    0.03781   3.966 0.000114 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n(Dispersion parameter for Gamma family taken to be 0.03501732)\n\n    Null deviance: 9.9564  on 151  degrees of freedom\nResidual deviance: 4.7078  on 147  degrees of freedom\nAIC: 1809\n\nNumber of Fisher Scoring iterations: 4\n\n\nSpecifically of interest here is this:\nDispersion parameter for Gamma family taken to be 0.03501732\nSo the simulation takes the first row of our dataset, considers the values of the predictors and builds a Gamma distribution conditional on the predictors using the “dispersion parameter”. The dispersion parameter is directly related to the scale parameter \\(\\theta\\). Now that we have this distribution, it randomly selects as many predicted values as we requested. In the example above, we set nsim = 10 so it selects 10 of them.\nOnce we have these 10 values, it compares each of them to the actual value of the outcome - again, this will come form our original dataset. The outcome will either be smaller or larger than each predicted value. Let’s stick with the first row:\n\nbelay_tib[1, ] |&gt; \n  display()\n\n\n\n\n\n\n\n\n\n\n\n\nsubj_id\nreaction_time\nassisted_break\ndistracted\nclimbing_exp\nfall_m\n\n\n\n\n1017\n847.40\n0\n1\n3.10\n2.10\n\n\n\n\n\nThe reaction time for the first row is 847.4. Now let’s look at the values simulated for this first row:\n\nsimulated_predictions[1, ] |&gt; \n  display()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nsim_1\nsim_2\nsim_3\nsim_4\nsim_5\nsim_6\nsim_7\nsim_8\nsim_9\nsim_10\n\n\n\n\n1006.77\n803.62\n921.61\n911.05\n605.46\n1109.80\n777.20\n912.47\n1117.32\n722.31\n\n\n\n\n\nThe outcome value is smaller than 6 of these predictions. If we want this as a proportion, we divide this by the number of simulations, which is 10 and get 0.6 .\nWe repeat this process for all of the rows. So next we create a distribution conditional on the values of the predictors in the 2nd row of belay_tib and then draw from it, then the 3rd row, 4th row, and so on until we’ve done this for all the rows. The function also draws more than 10 values - the default is 250. At the end of this process, we’ll have a proportion of cases in which the outcome is smaller and larger than the simulated values for each row. So in our case, we’ll have a distribution of 152 proportions. This distribution is then checked against a uniform distribution. If it’s a good enough match, we conclude the model is well specified. I’ve included some code below that demonstrates the whole process to the point of obtaining the final distribution. It’s not annotated, but if you’ve come this far you can have a go at unpicking what each line does.\n\nnsim &lt;-  250\nsim_data &lt;- simulate(belay_gamma, nsim = nsim)\n\nsim_data &lt;- sim_data |&gt; \n  dplyr::mutate(\n    actual_outcome = belay_tib$reaction_time\n  )\n\nsim_data &lt;- sim_data |&gt; \n  dplyr::mutate(\n    dplyr::across(\n      .cols = -actual_outcome,\n      .fns = \\(x) actual_outcome &lt; x\n    )\n  )\n\ncounts &lt;- sim_data |&gt; \n  dplyr::select(-actual_outcome) |&gt; \n  rowSums(na.rm = TRUE)\n\nproporions &lt;- counts / nsim\n\nggplot2::ggplot(data = NULL, aes(x = proporions)) + \n  geom_histogram(fill = \"yellowgreen\", colour = \"yellowgreen\", alpha = 0.5) + \n  theme_light()\n\n\n\n\n\n\n\n\nThe distribution above is the one compared against a uniform distribution.\nNow onto the issue of heteroscedasticity and Pearson residuals.\nYou may recall that we talked about how GzLM can model different types of variance between the predicted values and the variance (in the Mean-variance relationship section), including heteroscedastic ones. For Gamma models, this relationship is quadratic:\n\\[\nV(Y) = E(Y)^2\n\\]\nThat is, for each predicted value, the variance is expected to be that value squared. This is clearly the opposite of homoscedasticity so why then are we looking for it in Figure 1.2? That’s because we don’t expect to see heteroscedasticity in Pearson residuals.\nRaw residuals - the one we’re used to talking about in OLS models - are calculated as the difference between the actual value and the predicted value of the outcome:\n\\[\n\\epsilon^{raw}_i = y_i - \\hat\\mu_i\n\\]\nin which \\(\\hat\\mu_i\\) is the predicted value. We get extract the raw residuals out of our model if we so wish:\n\nfitted_values &lt;- belay_gamma$fitted.values\nactual_values &lt;- belay_tib$reaction_time\nraw_residuals &lt;- fitted_values - actual_values\n\nNow let’s plot them against the fitted values to get the “classic” diagnostic plot:\n\nggplot2::ggplot(data = NULL, aes(x = fitted_values, y = raw_residuals)) + \n  geom_point() + \n  theme_light()\n\n\n\n\n\n\n\n\nWould you look at that! The shape is funneling out, the heteroscedasticity is still there. But checking this plot as a way of diagnosing the Gamma model would tell us nothing of use because the model doesn’t assume the absence of heteroscedasticity.\nSo we look at the Pearson residuals instead, which are calculated as:\n\\[\n\\epsilon^{pearson}_i = \\frac{y_i - \\hat\\mu_i}{\\sqrt{V(\\hat\\mu_i)}}\n\\]\nThe top of the fraction is the same. The bottom part, specifically the \\(V\\) is the function for calculating variance in a given model, which changes depending on the distribution. This will “model away” the heteroscedsticity, which is why we’re still looking for a random non-funnelling shape when checking the diagnostics.\nIf you made it this far, well done. This is about the maximum amount of information I’m willing to know about the topic at this stage of my life. There is no more to be learned by asking me clarifying questions, but you can certainly try.\n\n\n\n\n\nCheck model fit\nAs usual, we want:\n\nThe overall fit statistics\nThe test of model fit\n\nAs previously, easystats has our back and we can just use the familiar functions.\n\nbelay_gamma |&gt; \n  performance() |&gt; \n  display()\n\n\n\nTable 1.1\n\n\n\n\n\n\nAIC\nAICc\nBIC\nNagelkerke’s R2\nRMSE\nSigma\n\n\n\n\n1809.0\n1809.6\n1827.2\n0.54\n100.17\n0.19\n\n\n\n\n\n\n\n\nThe main difference here is that instead of typical R2 we get so called, Nagelkerke’s R2 . The R2 in OLS linear model is based on least squares calculations. In GzLM, we’re using Maximum Likelihood estimation, so calculating R2 is not as straightforward. Nagelkerke’s R2 is therefore what we call “Pseudo R2” . It can be interpreted as regular R2 , that is, as the proportion of variance in the outcome explained by the model, although statisticians like to debate whether attempting to calculate R2 for ML based models even makes sense in the first place. We’ll leave it at that and use it.\nBased on the pseudo R2 , our model explains 53.53% of total variance in outcome.\nFinally, let’s test the model fit:\n\nbelay_gamma |&gt; \n  test_wald() |&gt; \n  display()\n\ncex Only one model was provided, however, at least two are required for\ncex   comparison.\ncex   Fitting a null-model as reference now.\n\n\n\n\n\nName\nModel\ndf\ndf_diff\nF\np\n\n\n\n\nNull model\nglm\n151\n\n\n\n\n\nFull model\nglm\n147\n4\n40.97\n&lt; .001\n\n\n\nModels were detected as nested (in terms of fixed parameters) and are compared in sequential order.\n\n\n\nOverall the Wald test indicates the model is good fit, F(4,147) = 40.97, p &lt; .001.\n\n\nParameter estimates\nFinally, let’s extract the parameter estimates:\n\nbelay_gamma |&gt; \n  parameters() |&gt; \n  display()\n\n\n\n\n\n\n\n\n\n\n\n\nParameter\nLog-Prevalence\nSE\n95% CI\nt(147)\np\n\n\n\n\n(Intercept)\n6.63\n0.09\n(6.45, 6.81)\n71.67\n&lt; .001\n\n\nassisted break\n-0.07\n0.03\n(-0.13, -8.61e-03)\n-2.23\n0.025\n\n\nclimbing exp\n-0.11\n0.01\n(-0.13, -0.09)\n-10.59\n&lt; .001\n\n\ndistracted\n0.13\n0.03\n(0.07, 0.19)\n4.29\n&lt; .001\n\n\nfall m\n0.15\n0.04\n(0.08, 0.22)\n3.97\n&lt; .001\n\n\n\n\n\nThese estimates are a little more tricky to interpret than we’re used to, but nothing we can’t handle. Remember how we used the link function which applied the logarithmic transformation to the expected values? Now need to reckon with this fact.\nThe parameter estimates as we see above are on the log scale. For example for assisted break, the model predicts -0.07 change in the log of the outcome with the change of one unit of the predictor. The estimate is negative, so we know that as the predictor increases, the log of the outcome decreases (whereas the opposite is true for distraction and fall height). But the values themselves are not particularly illuminating. Luckily, we can transform the betas in a way that will allow us to interpret them in the original units by exponentiating them. This is because exponentiation is the inverse function to the log.\n\nbelay_gamma_exp &lt;- belay_gamma |&gt; \n  parameters(exponentiate = TRUE) \n \nbelay_gamma_exp |&gt;  \n  display()\n\n\n\n\n\n\n\n\n\n\n\n\nParameter\nPrevalence Ratio\nSE\n95% CI\nt(147)\np\n\n\n\n\n(Intercept)\n753.74\n69.67\n(630.16, 902.53)\n71.67\n&lt; .001\n\n\nassisted break\n0.93\n0.03\n(0.88, 0.99)\n-2.23\n0.025\n\n\nclimbing exp\n0.89\n9.41e-03\n(0.88, 0.91)\n-10.59\n&lt; .001\n\n\ndistracted\n1.14\n0.03\n(1.07, 1.21)\n4.29\n&lt; .001\n\n\nfall m\n1.16\n0.04\n(1.08, 1.25)\n3.97\n&lt; .001\n\n\n\n\n\nNow the predictors that are negatively associated with the outcome have values smaller than 1, while predictors with positive association have values greater than 1. As we’ve seen in Figure 1.1, the relationship between the predictor and the outcome is not entirely linear so the interpretation of the parameters is not as simple as a change in one unit of the predictor associated with the change in the outcome. Instead, what we have is called the Prevalence Ratio. To make the interpretation of PR easier, we’re going to convert PR into percentage change associated with a change in one unit of the predictor. We do this by subtracting 1 from the estimate and then multiplying it by 100. We’ll do this for both the estimate and the confidence intervals:\n\nbelay_gamma_exp |&gt; \n1  tibble::as_tibble() |&gt;\n2  dplyr::mutate(\n3    perc_change = (Coefficient-1) * 100,\n4    perc_ci_lower = (CI_low-1) * 100,\n5    perc_ci_upper = (CI_high-1) * 100\n  ) |&gt; \n6  dplyr::select(-c(CI, df_error)) |&gt;\n  display() \n\n\n1\n\nTake the exponentiated parameter estimates and pipe them convert them into a tibble so we can make some calculations\n\n2\n\nPipe the tibble into the mutate function.\n\n3\n\nCalculate percentage change perc_change by subtracting each parameter estimate in the Coefficient column from 1 and then multiplying the result by 100.\n\n4\n\nPerform the same calculation for lower confidence interval.\n\n5\n\nperform the same calculation for upper confidence interval.\n\n6\n\nRemove unnecessary columns (optional).\n\n\n\n\n\n\nTable 1.2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nParameter\nCoefficient\nSE\nCI_low\nCI_high\nt\np\nperc_change\nperc_ci_lower\nperc_ci_upper\n\n\n\n\n(Intercept)\n753.74\n69.67\n630.16\n902.53\n71.67\n0.00\n75274.48\n62916.45\n90152.53\n\n\nassisted_break\n0.93\n0.03\n0.88\n0.99\n-2.23\n0.03\n-6.68\n-12.16\n-0.86\n\n\nclimbing_exp\n0.89\n9.41e-03\n0.88\n0.91\n-10.59\n3.30e-26\n-10.54\n-12.35\n-8.70\n\n\ndistracted\n1.14\n0.03\n1.07\n1.21\n4.29\n1.76e-05\n14.05\n7.41\n21.11\n\n\nfall_m\n1.16\n0.04\n1.08\n1.25\n3.97\n7.30e-05\n16.18\n7.97\n25.04\n\n\n\n\n\n\n\n\nLet’s take this row by row. The intercept is interpreted as usual - it’s the value of the outcome when all the predictors are 0. For this row, we ignore the perc_change columns we’ve just created.\nAssisted breaking device: We read the perc_change column here. For this predictor, participants who used an assisted breaking device had reaction time lower by -6.68% compared to those who used a regular belay device. Let’s give this a little more context and look at the predictions. Once again, we’re creating a helper prediction tibble with the values for which we want to make predictions. We’re holding all the values constant, apart from assisted_break where we want predicted reaction time for the participants who didn’t use a breaking device (0) as well as those who did (1). If you’re wondering where the other values came from, revisit section Making predictions.\n\nprediction_assisted_break &lt;- tibble::tibble(\n  climbing_exp = 6.14,\n  assisted_break = c(0, 1),\n  distracted = 0,\n  fall_m = 1.82\n)\n\nWe then use the predict function to make a prediction from our model:\n\n1predict(belay_gamma, newdata = prediction_assisted_break) |&gt;\n2  exp()\n\n\n1\n\nGenerate prediction\n\n2\n\nExponentiate from the log scale\n\n\n\n\n       1        2 \n499.8019 466.4167 \n\n\nThe first value is the prediction of the reaction time for those without an assisted breaking device (499.8019 ms) the second value predicts the RT for those with an assisted breaking device (466.4167 ms). As expected, the latter time is shorter. Based on our model, the predicted difference 6.68%. What’s 6.68% of 499.8019?\n\n499.8019 / 100 * 6.68\n\n[1] 33.38677\n\n\nNow if we subtract this difference from the predicted value…\n\n499.8019 - 33.38677\n\n[1] 466.4151\n\n\n… we get a predicted value for the second group (ignoring some rounding error on 3rd+ decimal place). This is why we sometimes call this type of parameter estimate a relative change: because we calculate the percentage change relative to a given value.\nClimbing experience: This is a continuous predictor but if you understood the principle of the previous section, this one is not much different. For each year of climbing experience, the model predicts a -10.54% decrease in reaction time. Based on the confidence intervals, this change could be as large as -12.35% or as small as -8.7%.\nThere’s one final thing we need to highlight about the Gamma models. Revisit Figure 1.1 . Recall that the linear prediction goes into infinity, including unrealistic predictions like negative reaction times. However, the “slope” of the Gamma line seems to be less steep the more we move to the right on climbing experience. This is were relative change really shines.\nSay we want to predict the reaction time for someone with two years of climbing experience:\n\npredict(\n  object = belay_gamma, \n  newdata = tibble::tibble(\n    climbing_exp = 2,\n    assisted_break = 0,\n    distracted = 0,\n    fall_m = 1.82\n  )\n) |&gt; exp()\n\ncex        1 \ncex 792.5492\n\n\nWe’ve put the prediction tibble directly into the function to speed things up a bit. While other predictors are held constant, the model predicts a reaction time of 792.5492 for someone who’s been climbing for 2 years. The estimated change for this predictor was 10.54%, which is:\n\n792.5492 / 100 * 10.54\n\n[1] 83.53469\n\n\nSo now we can calculate:\n\n792.5492 - 83.53469\n\n[1] 709.0145\n\n\nand 876.0839 is the reaction time predicted for someone with three years of experience.\nWhat if we took someone at the upper end of climbing experience, say 8 years?\n\npredict(\n  object = belay_gamma, \n  newdata = tibble::tibble(\n    climbing_exp = 8,\n    assisted_break = 0,\n    distracted = 0,\n    fall_m = 1.82\n  )\n) |&gt; exp()\n\ncex        1 \ncex 406.2939\n\n\nThe predicted reaction time is 406.2939, and 10.54% of this value is:\n\n406.2939 / 100 * 10.54\n\n[1] 42.82338\n\n\n42.82. So the value that we’re subtracting becomes lower and lower the further up we move on climbing experience. This effectively prevents us from falling into absurd predictions. Eventually, the prediction line would plateau and be almost completely flat, which makes sense - there’s a physical limit of how fast someone can react.\n\n\nReport\nWhen reporting any model, we want to strike a balance between reporting all the necessary bits of information and interpreting the parameter estimates in a way that allows us to make conclusions about the hypothesis. Here’s an example of how you could approach but don’t feel beholden to this:\n\nWe fitted a Gamma Generalised Linear Model with the log link function predicting belayers reaction time assisted device use and climbing experience. The covariates in the model were the belayers’ climbing experience and whether they were distracted when belaying their climbing partner.\nBased on the posterior predictive checks and residual diagnostics, the model appeared to be well specified. Overall, the model was a good fit, F(4,147) = 40.97, p &lt; .001, and explained 53.53% of variance in the outcome, R2 = 0.54.\nIn line with Hypothesis 1, assisted breaking device was a statistically significant predictor of the time it took belayers to stop their climbers’ fall, b = 0.93, 95% CI [0.88, 0.99], SE = 0.03, t = -2.23, p = 0.025, while other predictors were held constant. Belayers who used an assisted breaking device were -6.68% quicker to stop the fall compared to those who didn’t. 95% confidence intervals indicated this difference could be as large as -12.16 or as small as -0.86. This effect was small translated into a difference of 33.38 ms.\nHypothesis 2 was also supported by a statistically significant effect of climbing experience, b = 0.89, 95% CI [0.88, 0.91], SE = 0.01, t = -10.59, p &lt; .001, while holding other predictors constant. A year of climbing experience was associated with a decrease of -10.54%, 95% CI [-12.35%, -8.7%] in belayers’ reaction time. This effect was especially large for belayers with less climbing experience - for example, the model predicted that a belayer with one year of climbing experience would take 885.91 ms to stop a fall while a belayer with two years of experience would take 792.54 ms - a difference of 93.36 ms, which can make a practical difference to the safety of the climber, especially when falling from a lower height where the likelihood of injury is increased.\nThe effects of both covariates (distraction and fall height) - were also statistically significant - full results are reported in Table 1.2.",
    "crumbs": [
      "Generalised Linear Models",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Modelling skewness</span>"
    ]
  },
  {
    "objectID": "01a_gzlms_skewed.html#exercises",
    "href": "01a_gzlms_skewed.html#exercises",
    "title": "1  Modelling skewness",
    "section": "1.2 Exercises",
    "text": "1.2 Exercises\n\nWhat does this code do?\n\n\n\n\n\n\nHere’s all the code we have written in this section. Can you remember what each line of each codechunk does? Are there any codechunks that you struggle to make sense of? Make sure to revisit the section in which it is used and take notes.\n\n\n\n\nlibrary(easystats)\nlibrary(tidyverse)\n\nbelay_tib &lt;- here::here(\"data/climbing_data.csv\") |&gt;\n  readr::read_csv()\n\n\ngamma_dist &lt;- rgamma(n = 10000, shape = 1, scale = 2)\n\nggplot2::ggplot(data = NULL, aes(x = gamma_dist)) +\n  geom_density()\n\n\n... + \nstat_smooth(method = \"glm\", colour = \"darkorange\", fill = \"darkorange\", \n            method.args = list(family = \"Gamma\")) + \n...\n\n\nbelay_tib |&gt; \n  ggplot2::ggplot(data = _, aes(x = climbing_exp, y = reaction_time)) + \n  geom_point(alpha = 0.7, colour = \"yellowgreen\") + \n  stat_smooth(method = \"lm\", colour = \"steelblue\", fill = \"steelblue\") + \n  stat_smooth(method = \"glm\", \n              colour = \"darkorange\", fill = \"darkorange\", \n              linetype = \"dashed\",\n              method.args = list(family = \"Gamma\")) + \n  coord_cartesian(xlim = c(0, 10), ylim = c(0, 1030.5)) + \n  labs(x = \"Belayer's climbing experience (in years)\", y = \"Reaction time (ms) to break the fall\") + \n  theme_light() \n\n\nbelay_gamma &lt;- glm(\n  reaction_time ~ assisted_break + climbing_exp + distracted + fall_m,\n  family = Gamma(link = \"log\"), \n  data = belay_tib \n)\n\n\nbelay_gamma |&gt; check_model()\n\n\nbelay_gamma |&gt; \n  performance() |&gt; \n  display()\n\n\nbelay_gamma |&gt; \n  test_wald() |&gt; \n  display()\n\n\nbelay_gamma |&gt; \n  parameters() |&gt; \n  display()\n\n\nbelay_gamma_exp &lt;- belay_gamma |&gt; \n  parameters(exponentiate = TRUE) \n \nbelay_gamma_exp |&gt;  \n  display()\n\n\nbelay_gamma_exp |&gt; \n  tibble::as_tibble() |&gt; \n  dplyr::mutate( \n    perc_change = (Coefficient-1) * 100, \n    perc_ci_lower = (CI_low-1) * 100, \n    perc_ci_upper = (CI_high-1) * 100 \n  ) |&gt; \n  dplyr::select(-c(CI, df_error)) |&gt; \n  display() \n\n\npredict(\n  object = belay_gamma, \n  newdata = tibble::tibble(\n    climbing_exp = 2,\n    assisted_break = 0,\n    distracted = 0,\n    fall_m = 1.82\n  )\n) |&gt; exp()\n\n\npredict(\n  object = belay_gamma, \n  newdata = tibble::tibble(\n    climbing_exp = 8,\n    assisted_break = 0,\n    distracted = 0,\n    fall_m = 1.82\n  )\n) |&gt; exp()\n\n\n\nWorksheet\nScenario:\n\nThe International Civil Aviation Organisation is reviewing the efficiency of the alerts for the Ground Proximity Warning System (GPWS), which warns pilots when the aircraft is too close to the ground or other terrain (like mountains). Currently, the GPWS alerts the pilots by an auditory signal. The aviation authority is deciding whether to replace the auditory signal with a visual one. Because light moves as at a faster speed than sound, they hypothesise that:\nH1: Pilots will be able to respond significantly faster to visual stimuli, compared to auditory stimuli.\nThey hired you as a cognitive scientist to carry out an experiment and recommend a policy change if appropriate. During the experiment, novice pilots without experience of the existing GPWS were placed in a flight simulator and presented with a warning at a random point during the flight. This warning is either auditory or visual (warning_modality, auditory coded as 0, visual coded as 1) and it is displayed either as a simple signal (a short alarm for the auditory modality or a light indicator for the visual modality), or as a brief message with the instruction “Terrain, pull up!” - either spoken or displayed on a flight monitor (signal_complexity, simple alert coded as 0, message coded as 1). You also measured the pilots’ subjective perception of their own alertness (alertness) ranging from 0 (not alert) to 10 (very alert) and the time from the beginning of the flight to the point when GPWS was triggered in minutes (gpws_time). All of these variables should be included as the predictors in the model. The outcome was measured as the time it took the pilots to respond to the warning with a corrective action in milliseconds (response_time).\n\n\n\n\n\n\n\nUse the tutorial to complete the following tasks:\n\nGenerate descriptive statistics and an informative data visualisation for the hypothesis\nFit two models\n\nModel 1: Assuming a normal conditional distribution for the outcome. Call the model alert_glm .\nModel 2: Assuming a gamma conditional distribution for the outcome. Call the model alert_gamma .\n\nEvaluate the model assumptions and the overall fit for both models. Decide which modelling approach is more appropriate.\nGenerate the parameter estimates for the model you selected in the previous step.\nWrite up a short report (up to 300 words), including:\n\nA summary of your evaluation in Task 3\nOverall fit statistics\nInterpretation of the parameter estimates\nPolicy recommendation based on the results\n\n\n\n\n\nYou can use the “worksheet” file in the quarto folder to prepare the worksheet. The data are stored in the file alert_data.csv. Download the data and import it to Posit Cloud. Once you’ve done so, you can read the data into R by running:\n\nalert_tib &lt;- readr::read_csv(\"data/alert_data.csv\")\n\nRemember to load the necessary packages.\n\n\n\n\n\n\nOptional extra task:\nUse alert_glm and alert_gamma to make two separate response time predictions for a pilot who was presented with a visual alert in form of a short message, and who’s subjective alertness and flight duration before the alert were at the average levels found in the sample.\n\n\n\n\n\nCheck worksheet values\nOnce you’ve finished the worksheet, you can ask the tutor to look through your work and give you feedback. Remember that you should also practice writing up the results in a brief report, not just running the code. If you’re stuck, you can use the quiz below to guide you.\nYou can also use the quiz below - if you fitted the models the correctly, your answers should match the correct answers in the quiz. Round all your answers to 2 decimal places. If making calculations, only round the final result.\n\n\n\n\n\n\nWorksheet check\n\n\n\n\n\nHow alert were the pilots in the study on average? \nWhat was the average time from the start of the flight to the point of the alert? \nThe Gaussian model predicts an increase of  milliseconds in response time for the visual modality compared to the auditory modality.\nWhich two assumptions of OLS estimation are the most obviously violated for Gaussian model?\n\n Linearity and influential cases Linearity and heteroscedasticity Normal errors and influential cases Heteroscedasticity and collinearity Heteroscedasticity and normal errors Collinearity and influential cases Collinearity and normal errors\n\nBased on the posterior predictive check, which model is a better fit?\n\n Gamma model Gausian model\n\nThe Gamma model explained  percent of total variance in the outcome. Compared to the Gaussian model, this proportion was greater by  percent.\nOverall, the Gamma model was a good fit, F(,) = , p &lt; .001.\nThe time it took the pilots to respond to visual stimuli was  percent greater compared to response times to auditory signals. Based on this the proposed change from auditory signals to visual signals…\n\n … should be implemented. … should NOT be implemented\n\nOptional task:\nFor a pilot presented with a visual alert who’s subjective alertness and flight duration before the alert were at average levels, the Gaussian models predict the response time of  milliseconds, while the Gamma model predicts a response time of  milliseconds.",
    "crumbs": [
      "Generalised Linear Models",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Modelling skewness</span>"
    ]
  },
  {
    "objectID": "01a_gzlms_skewed.html#footnotes",
    "href": "01a_gzlms_skewed.html#footnotes",
    "title": "1  Modelling skewness",
    "section": "",
    "text": "You could substitute the term “expected” with “predicted”. The only difference is that we tend to use “predicted” when talking about a single value, and “expected” when talking about a whole distribution, but for all intents and purposes, they are the same.↩︎",
    "crumbs": [
      "Generalised Linear Models",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Modelling skewness</span>"
    ]
  },
  {
    "objectID": "01d_gzlms_summary.html",
    "href": "01d_gzlms_summary.html",
    "title": "Summary",
    "section": "",
    "text": "Canonical link functions\n\n\n\n\n\n\n\n\n\nDistribution\nUseful for…\nCanonical link function\nInverse function\n\n\n\n\nGamma\nRight skewed distributions\nlog\nexp",
    "crumbs": [
      "Generalised Linear Models",
      "Summary"
    ]
  },
  {
    "objectID": "01_gzlms.html",
    "href": "01_gzlms.html",
    "title": "Generalised Linear Models",
    "section": "",
    "text": "Scenario",
    "crumbs": [
      "Generalised Linear Models"
    ]
  },
  {
    "objectID": "01_gzlms.html#scenario-gzlms",
    "href": "01_gzlms.html#scenario-gzlms",
    "title": "Generalised Linear Models",
    "section": "",
    "text": "A researcher in sports psychology is interested in understanding the factors related to the reaction times of belayers1 when breaking a fall of their climbing partners. She set up ultra-high resolution cameras at the local gym, then reviews the footage and records: the time it took for the belayer to effectively stop the fall after the climber lost control in milliseconds (reaction_time); whether the belayer used an assisted-breaking device (assisted_break - no/yes); and whether the belayer was talking to others or was otherwise distracted (distracted - no/yes). The researcher also collected information about the participants’ climbing experience in years (climbing_exp), and the length of the climbers’ fall in metres (fall_m).\nThe researcher hypothesises the following:\nH1: More experienced belayers will be faster to catch falls.\nH2: Belayers using an assisted breaking device will be faster to catch falls.\n\n\nThe data\nThe (fictional) dataset is stored in the file climbing_data.csv . First, let’s load up the necessary packages. Then, assuming you have imported the dataset into the data folder on Posit Cloud, you can read it into your R session as:\n\n1library(easystats)\n2library(tidyverse)\n\n3belay_tib &lt;- here::here(\"data/climbing_data.csv\") |&gt;\n4  readr::read_csv()\n\n\n1\n\nLoad the easystats package\n\n2\n\nLoad the tidyverse package\n\n3\n\nSpecify the directory of the dataset with the here function.\n\n4\n\nRead the data, storing the result of this code into an object called belay_tib.\n\n\n\n\nLet’s inspect the dataset to make sure it read in properly:\n\nbelay_tib\n\n\n\n\n\nTable 1\n\n\n\n\n\n\n\n\n\n\n\nWe have six variables here: the ID of the participant subj_id , the outcome reaction_time and four predictors as specified in the Scenario above. assisted_break and distracted are currently encoded as 0s and 1s, 0 standing for “No” and 1 standing for “Yes”.\n\n\n\n\n\n\nFactors and binary categorical predictors\n\n\n\n\n\nIdeally, categorical predictors should be encoded as factors with meaningful labels. However if a categorical predictor with two categories is coded as 0 and 1, we don’t strictly need to convert them into factors. Zeros and ones are exactly what we use when dummy coding, so we can use these variables as they are to fit a model. R will cope just fine and the statistics will be valid. The output will just not be as helpfully labelled, so we need to remember that the beta for these predictors will tell is how larger or smaller the estimate of the category coded as 1 is compared to the category coded as 0.\nSituations where we absolutely have to convert into factors or out right dummy codes include: when the nummeric categories are different to 0 and 1 (e.g. they’re 1 and 2, or 2 and 3 for whatever reason) or when there are more than two categories. Especially in the latter case, it makes no sense to treat a categorical predictor with three categories as if it was continuous.\n\n\n\n\n\nDescriptive statistics\nThe next few steps should be familiar. We start by generating some descriptive summaries:\n\n1belay_tib |&gt;\n2  describe_distribution(select = -subj_id) |&gt;\n3  display()\n\n\n1\n\nTake the object belay_tib -\n\n2\n\nPipe it into describe_distribution() which will provide general descriptive summaries. We’re including some optional arguments:\n\n3\n\nApply formatting to create a nicer looking table (optional, but useful for e.g. writing reports)\n\n\n\n\n\n\nTable 2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVariable\nMean\nSD\nIQR\nRange\nSkewness\nKurtosis\nn\nn_Missing\n\n\n\n\nreaction_time\n523.14\n141.68\n172.73\n(316.12, 1030.44)\n1.21\n1.79\n152\n0\n\n\nassisted_break\n0.52\n0.50\n1.00\n(0.00, 1.00)\n-0.08\n-2.02\n152\n0\n\n\ndistracted\n0.49\n0.50\n1.00\n(0.00, 1.00)\n0.03\n-2.03\n152\n0\n\n\nclimbing_exp\n6.14\n1.48\n1.97\n(2.10, 9.70)\n-0.22\n0.28\n152\n0\n\n\nfall_m\n1.82\n0.41\n0.60\n(0.90, 3.00)\n0.19\n0.06\n152\n0\n\n\n\n\n\n\n\n\n\nWe have no missing values, for any of the variables (good to know). Reaction time (RT) is in millisecond so the average reaction time for stopping a fall was a little over half a second (523.14 ms). The quickest belayer caught a fall in 316 ms and the slowest in 1030 ms. On average, belayers had a climbing experience of 6.14 years, ranging from 2.1 to 9.7 years. Average fall length was 1.82 metres. The smallest recorded fall was 0.9 metres, the longest was 3 metres.We’re not interested in central tendency, dispersion, or skewness and kurtosis for the assisted_break and distracted (it makes no sense to inspect these for categorical predictors).\nClimbing experience and fall distance show low levels of skewness and kurtosis. However, our outcome variable is positively skewed (skewness = 1.21), and has excess kurtosis substantially above 0 (kurtosis = 1.79).\nThis is not that surprising. Reaction times are bound at 0 (you cannot have a negative reaction time) and unbound on the opposite tail, so it really doesn’t make sense to expect a normal distribution, which is unbound on both ends. Even if we don’t have this intuition, reaction time is the best documented and most stereotypical variable known to have a skewed distribution. Despite this, researchers often model it with estimators that rely on normal distribution (somewhere in the process), simply because it’s convenient. So for now, we’re going to assume ignorance to see whether we can pry something meaningful out of the model using a regular linear model.\n\n\n\n\n\n\nNormal distribution of the outcome\n\n\n\n\n\nRemember that when we’re fitting an OLS-based linear model, the normal distribution of the outcome variable is not one of the assumptions. The actual assumption refers to the errors in the population model, which are best checked by inspecting the model residuals. However, the outcome variable will often (but not always) have a similar distribution to the residuals. It is therefore useful to inspect it in the initial stage, but we’ll still need to run the residual diagnostics after we’ve fitted the model.\n\n\n\n\n\nVisualisation\nFor data visualisation, we’ll want:\n\nA plot showing the hypothesised relationships between each predictor and the outcome.\nA plot showing the distribution of the outcome, just so we have a better sense of what the variable looks like\n\nLet’s start with H1:\n\nbelay_tib |&gt; \n1  ggplot2::ggplot(data = _, aes(x = climbing_exp, y = reaction_time)) +\n2  geom_point(alpha = 0.7, colour = \"yellowgreen\") +\n3  stat_smooth(method = \"lm\", colour = \"steelblue\", fill = \"steelblue\") +\n4  coord_cartesian(xlim = c(0, 10), ylim = c(0, 1030.5)) +\n5  labs(x = \"Belayer's climbing experience (in years)\", y = \"Reaction time (ms) to break the fall\") +\n6  theme_light()\n\n\n1\n\nSpecify the dataset and the aesthetics\n\n2\n\nAdd raw data points\n\n3\n\nAdd the line of best fit\n\n4\n\nScale the y axis and the x axis to reflect the realistic scale of our outcome variable (the maximum value 1030.5 is based on values from Table 2)\n\n5\n\nAdd meaningful labels\n\n6\n\nAdd a theme (optional but generally a good idea)\n\n\n\n\n\n\n\n\n\n\nFigure 1\n\n\n\n\n\n\n\n\n\n\n\nLearning about ggplots\n\n\n\n\n\nggplot is a fantastic tool but the code is objectively difficult to remember - it’s chonky, and each line has far too many options for customisation. When working with ggplot code, don’t just copy and paste the whole code chunk and call it a day - instead, write the first line, run it, see what it does. Then write the second line, add it to the plot, and see what changes. And so on. This goes for any code that’s longer than just a couple of lines. By writing it line by line, you’ll get a better understanding of what the code does, which bits are crucial and which ones are just “nice to have”. For example, I didn’t need to change the colour of the points in line 3, nor did I need to add the jitter, or the labels for the x and y axis. Without these, the plot would still be understandable. But adding these elements the plot more readable and accessible.\n\n\n\n\nNow let’s do the same for H2\n\nbelay_tib |&gt; \n1  ggplot2::ggplot(data = _, aes(x = factor(assisted_break), y = reaction_time)) +\n2  geom_point(alpha = 0.7, colour = \"yellowgreen\", position = position_jitter(width = 0.1)) +\n3  stat_summary(fun.data = \"mean_cl_normal\") +\n4  coord_cartesian(ylim = c(0, 1030.5)) +\n5  labs(x = \"Did the belayer used an assisted breaking device\", y = \"Reaction time (ms) to break the fall\") +\n6  theme_light()\n\n\n1\n\nSpecify the dataset and which variable to put on each of the axes. Note that we’re wrapping assisted_break in the factor() function, so the plot treats it as such. This is optional. Again, it would have been better to convert the variable to the factor at the very beginning, but we’re keeping it as numeric for now because it makes some of the later calculations easier.\n\n2\n\nAdd raw data points - this is good for inspecting potentially unusual cases\n\n3\n\nAdd the mean and confidence intervals - this time, the predictor is categorical so we use stat_summary instead of stat_smooth\n\n4\n\nScale the y axis\n\n5\n\nAdd meaningful labels\n\n6\n\nAdd a theme\n\n\n\n\n\n\n\n\n\n\nFigure 2\n\n\n\n\n\nFinally, let’s have a look at the distribution of the outcome:\n\nbelay_tib |&gt; \n  ggplot2::ggplot(data = _, aes(x = reaction_time)) + \n  geom_density(colour = \"steelblue\", fill = \"steelblue\", alpha = 0.1) + \n  labs(x = \"Reaction time (ms) to break the fall\", y = \"Density\") + \n  theme_light()\n\n\n\n\n\n\n\nFigure 3\n\n\n\n\n\nNo code description for this one - see if you can work it out!\n\nFrom Figure 1, we see that there is quite a steep negative relationship between climbing experience of the belayer and reaction time - the more experience the belayer is, the shorter they take to respond. At a glance, it also seems like the belayers who used an assisted-breaking device were slightly faster to react compared to those who didn’t (Figure 2).\nFinally, Figure 3 confirms what Table 2 told us - that the outcome variable is right-skewed, with most values clustered towards the lower end an asymmetrical right tail. Without further ado, let’s confidently ignore this fact and hope for the best when fit an OLS linear model.",
    "crumbs": [
      "Generalised Linear Models"
    ]
  },
  {
    "objectID": "01_gzlms.html#ordinary-least-squares-estimation",
    "href": "01_gzlms.html#ordinary-least-squares-estimation",
    "title": "Generalised Linear Models",
    "section": "Ordinary Least Squares estimation",
    "text": "Ordinary Least Squares estimation\n\nFit the model\nWe can fit the linear model with all four predictors as:\n\nbelay_lm &lt;- lm(reaction_time ~ assisted_break + climbing_exp + distracted + fall_m, data = belay_tib)\n\nBefore diving straight into the result, we’ll need to check the model assumptions and assess the model fit.\n\n\nCheck model assumptions\n\nbelay_lm |&gt; check_model()\n\n\n\n\n\n\n\nFigure 4\n\n\n\n\n\nRight of the bat, we have problems. The posterior predictive check (row 1 left) shows that the distribution of values predicted by the model doesn’t align with the distribution observed in the dataset. There appears to be slight non-linearity, and the spread of the residuals is greater as we move right along the x axis (row 1 right) - this indicates the errors are heteroscedastic. This is confirmed by the fact that the line is not completely flat in row 2 left plot. There don’t appear to be any influential observations, but case 19 has Cook’s distance that is close to the cut-off of 0.8 (row 2 right). No particular issues with collinearity (row 3 left). Finally, the Q-Q plot in row 3 right confirms what we suspect based on the outcome distribution - that the distribution of the residuals is skewed with potentially extreme values, as evident by the right tail lifting above the horizontal reference line.\n\n\nCheck model fit\nWe can get the overall fit statistics:\n\nbelay_lm |&gt; \n  performance() |&gt; \n  display()\n\n\n\n\nAIC\nAICc\nBIC\nR2\nR2 (adj.)\nRMSE\nSigma\n\n\n\n\n1848.0\n1848.6\n1866.1\n0.48\n0.47\n101.54\n103.26\n\n\n\n\n\n\nAnd test the overall fit:\n\nbelay_lm |&gt; \n  test_wald() |&gt; \n  display()\n\n\n\n\nName\nModel\ndf\ndf_diff\nF\np\n\n\n\n\nNull model\nlm\n151\n\n\n\n\n\nFull model\nlm\n147\n4\n34.33\n&lt; .001\n\n\n\nModels were detected as nested (in terms of fixed parameters) and are compared in sequential order.\n\n\n\nThe model appears to be a good fit and a statistically significant improvement over a model where the reaction time is predicted from intercept alone, F(4,147) = 34.33, p &lt; .001 , explaining 48.3% of total variance, R2 = 0.48 , R2adj = 0.47 . However, before we congratulate ourselves, let’s remember that the model assumptions were violated in almost every respect, so we might want to address this in some way.",
    "crumbs": [
      "Generalised Linear Models"
    ]
  },
  {
    "objectID": "01_gzlms.html#robust-estimation",
    "href": "01_gzlms.html#robust-estimation",
    "title": "Generalised Linear Models",
    "section": "Robust estimation",
    "text": "Robust estimation\nRobust estimation is one approach that can be used for dealing with violated assumptions - instead of interpreting the parameters from the OLS model, we fit a robust model that is not sensitive (or less sensitive) to violated assumptions. We then use the parameter estimates from this model to draw conclusions about the hypotheses.\nThere are many robust methods out there. To recap, some include:\n\nBootstrapping - useful in small samples when normal errors cannot be assumed\nHeteroscedasticity-consistent standard errors - useful when homoscedasticity cannot be assumed\nM-type estimators - useful when we have influential cases or asymmetric error distributions, but can also deal with heteroscedasticity.\n\nGiven that we’re dealing with asymmetric errors, heteroscedasticity, and potential influential cases (Figure 4), let’s fit an MM-estimator:\n\nbelay_rob &lt;- robustbase::lmrob(reaction_time ~ assisted_break + climbing_exp + distracted + fall_m, data = belay_tib)\n\nWe can now request the parameter estimates:\n\nbelay_rob |&gt; \n  parameters() |&gt; \n  display()\n\n\n\nTable 3\n\n\n\n\nFixed Effects\n\n\n\n\n\n\n\n\n\n\nParameter\nCoefficient\nSE\n95% CI\nt(147)\np\n\n\n\n\n(Intercept)\n689.26\n53.94\n(582.66, 795.86)\n12.78\n&lt; .001\n\n\nassisted break\n-26.77\n14.04\n(-54.52, 0.98)\n-1.91\n0.059\n\n\nclimbing exp\n-53.49\n6.23\n(-65.79, -41.18)\n-8.59\n&lt; .001\n\n\ndistracted\n50.84\n15.48\n(20.26, 81.42)\n3.29\n0.001\n\n\nfall m\n76.16\n20.66\n(35.33, 116.99)\n3.69\n&lt; .001\n\n\n\n\n\n\n\n\n\nThere is a negative but non-significant difference in reaction time between belayers who used an assisted breaking device compared to those who didn’t, b = -26.77, 95% CI [-54.52, 0.98], SE = 14.04, t = -1.91, p = 0.059 - those using a breaking device were only -26.77 quicker. Based on this we cannot reject the null hypothesis of no difference between belaying devices.\nBelayers with more climbing experience were faster to stop a fall, while holding other predictors constant, b = -53.49, 95% CI [-65.79, -41.18], SE = 6.23, t = -8.59, p &lt; .001. With a one year increase in climbing experience, we can expect the reaction time to reduce by -53.49 . The 95% confidence interval suggest this reduction could be as large as -41.18 or as low as -65.79 , assuming this confidence interval is one the 95% that contain the true population value. If the null hypothesis were true, the probability of finding an effect this large is sufficiently unlikely, p &lt; .001. We therefore reject the hypothesis of null effect and retain H2.\n\n\n\n\n\n\nWhat’s with this awful language…\n\n\n\n\n\nLook, if it helps you make sense of this, here’s a slightly more direct version:\n\nIt is unlikely that we would find this difference if the effect itself was in reality 0, p &lt; .001, which is in support of H2.\n\nHowever, it is technically and statistically incorrect . A statistically significant p-value can never provide support for an alternative hypothesis, no matter how small. It only tells us if the alternative hypothesis is sufficiently unlikely if the null is true, but it doesn’t tell the probability of the null or the alternative hypothesis being true. Bayes Factors can tell us that, but that’s a whole other module.\n\n\n\nThe effects of both covariates were also statistically significant. Distracted belayers were slower to react b = 50.84, 95% CI [20.26, 81.42], SE = 15.48, t = 3.29, p = 0.001 , while an increase in 1 metre of fall length was associated with an increase of 76.16 milliseconds in time taken to stop the fall (p &lt; .001). This is not surprising, is the climber had a greater distance to fall before the rope ran out of slack.",
    "crumbs": [
      "Generalised Linear Models"
    ]
  },
  {
    "objectID": "01_gzlms.html#making-predictions",
    "href": "01_gzlms.html#making-predictions",
    "title": "Generalised Linear Models",
    "section": "Making predictions",
    "text": "Making predictions\nNow that we’ve caught up, let’s push our models even further. Generally, there are two reasons why we might want to build a statistical model. (1) To test a theory and help build a theoretical framework by explaining the roles of key variables or (2) to make a prediction. These two are not mutually exclusive.\nRecall that a linear model can be describe as:\n\\[\nY_i = \\beta_0 + \\beta_1X_{1i} + \\beta_2X_{2i} + ... + \\beta_nX_{ni} + \\varepsilon_i\n\\]\nThat is, the outcome \\(Y\\) for the participant \\(i\\) is predicted from the sum of the intercept \\(\\beta_0\\) a value of each predictor for that participant (\\(X_1, X_2...\\)), multiplied by the parameter estimate for each predictor, respectively (\\(\\beta_1 , \\beta_2 ...\\)). Each participant will also have their own error in prediction \\(\\varepsilon_i\\) .\n\nPredictions within the observed data\nThe equation specific to our model is:\n\\[\n\\begin{split}\n\\mbox{reaction time}_i = \\beta_0 &+ \\beta_1\\mbox{assisted break}_{i} \\\\\n&+ \\beta_2\\mbox{climbing experience}_{i} \\\\\n&+ \\beta_3\\mbox{distracted}_{i} \\\\\n&+ \\beta_4\\mbox{fall distance}_{i} \\\\\n& + \\varepsilon_i\n\\end{split}\n\\]\nWe’ve worked out the beta values, so let’s plug them in from Table 3 :\n\\[\n\\begin{split}\n\\mbox{reaction time}_i = 689 &-26.77*\\mbox{assisted break}_{i} \\\\\n&- 53.49*\\mbox{climbing experience}_{i} \\\\\n&+ 50.84*\\mbox{distracted}_{i} \\\\\n&+ 76.16*\\mbox{fall distance}_{i} \\\\\n&+ \\varepsilon_i\n\\end{split}\n\\]\nLet’s test this - how about we use the predictor values from the first participant from our dataset in Table 1 to see if we can use our model to predict their outcome?\nHere are their values:\n\nbelay_tib[1, ] |&gt; \n  display()\n\n\n\n\n\n\n\n\n\n\n\n\nsubj_id\nreaction_time\nassisted_break\ndistracted\nclimbing_exp\nfall_m\n\n\n\n\n1017\n847.40\n0\n1\n3.10\n2.10\n\n\n\n\n\n\nWe can assign these values into objects and then rewrite the equation.\n\nassisted_break_i &lt;- 0 \nclimbing_exp_i &lt;- 3.1\ndistracted_i &lt;- 1\nfall_m_i &lt;- 2.1 \n\n689.29 - 26.77 * assisted_break_i - 53.49 * climbing_exp_i + 50.84 * distracted_i + 76.16 * fall_m_i\n\n[1] 734.247\n\n\nIf we run the code chunk above, the model predicts that the first participant should have a reaction time of milliseconds. However, their actual reaction was 847.4. This is because we forgot the last part of the equation, \\(\\varepsilon_i\\). This represents the residual for our participant. We can extract it from the model and add it to the equation:\n\nresidual_i &lt;- belay_rob$residuals[1] # extract the residual for the first participant\n\n689.29 - 26.77 * assisted_break_i - 53.49 * climbing_exp_i + 50.84 * distracted_i + 76.16 * fall_m_i + residual_i\n\n       1 \n847.4194 \n\n\nIn this case, the value matches perfectly, but this only works if we are predicting values that are already in the model, because we can extract the residual direct. In practice, we often want to predict values for individuals who are not in the dataset - in such a case we accept we’ll often be slightly off because we don’t know how large the residual could be, but our prediction is our best guess that will result in the least possible error.\n\n\n\n\n\n\nIs there an easier way…?\n\n\n\n\n\nYes. R automatically computes the values your model predicts for every single participant. We did this manually above using the equation, but we could have just as easily done it with code. Fitted values can be accessed as:\n\nbelay_rob$fitted.values\n\nThis is a list of values that corresponds to the rows in our dataset. So the first value corresponds to the predicted value of reaction for the first participant:\n\nbelay_rob$fitted.values[1]\n\n       1 \n734.2276 \n\n\nThis is exactly the value we calculated manually, so it’s good to know our maths works!\n\n\n\n\n\nGoing beyond the data\nThe nice thing about modelling relationships as straight lines is that once we know the intercept and the slope, we can pretty much extend the line in either direction and make predictions for values that are not represented in your dataset. Consider Figure 1 . Although the line only spans the range of the data, we could extend each end to make predictions.\nSay that we’re interested in what the model predicts for individuals with no climbing experience, or, on the other hand, with extensive climbing experience. We’re going to create a new tibble with the values of climbing_exp for which we want to predict, that is, for belayers with anywhere between 0 and 20 years of experience.\nThen we’ll hold the other predictors constant. For factors, we’ll hold the values at the baseline, so 0 or “No” for both assisted_break and distracted . The continuous predictor - fall length - will be held constant at the average value of fall_m from Table 2 . We’ll use the tibble function and store the result into an object called prediction_tib .\n\nprediction_tib &lt;- tibble::tibble(\n  climbing_exp = 0:20,\n  assisted_break = 0,\n  distracted = 0,\n  fall_m = 1.82\n)\n\nInspect the tibble:\n\nprediction_tib\n\n\n\n\n\n\n\n\nAs requested, values in all rows are identical except for climbing_exp, which is changing. Now we can use this table to make predictions. The predict function is very handy here: it only takes two arguments: the model and the tibble with values which we want to use for prediction.\nOn its own, it can be used like this:\n\npredict(belay_rob, prediction_tib)\n\nWhich returns a vector of predicted values. Let’s be a little more efficient - we’re going to take the tibble we’ve just created - prediction_tib and use the mutate function to create a new column called predicted_rt . This column is created by applying the predict function:\n\n1prediction_tib &lt;- prediction_tib |&gt;\n2  dplyr::mutate(\n3    predicted_rt = predict(belay_rob, prediction_tib)\n  )\n\n\n1\n\nTake the existing prediction_tib. We’re updating an existing object instead of creating a new one, so the assignment operator &lt;- is also pointing towards prediction_tib.\n\n2\n\nUse the mutate function to create a new variable.\n\n3\n\nCall this new variable predicted_rt. Create predicted_rt by applying the predict function to the robust model belay_rob and the prediction_tib which contains all the values for which we’re trying to generate predictions.\n\n\n\n\n\nOnce again, let’s inspect our work:\n\nprediction_tib\n\n\n\n\n\n\n\n\nThis time the tibble has an extra column with predicted values. If you inspected the predicted_rt values, you may already noticed that something is wrong. Let’s add these on a plot so we can see the prediction more clearly:\n\nbelay_tib |&gt; \n  ggplot2::ggplot(data = _, aes(x = climbing_exp, y = reaction_time)) + \n  geom_point(alpha = 0.7, colour = \"yellowgreen\") + \n  stat_smooth(colour = \"darkred\", data = prediction_tib, aes(x = climbing_exp, y = predicted_rt)) +\n  labs(x = \"Belayer's climbing experience (in years)\", y = \"Reaction time (ms) to break the fall\") + \n  theme_light() \n\n\n\n\n\n\n\nFigure 5\n\n\n\n\n\nWe start the scatterplot above as usual. Then we add stat_smooth but instruct ggplot to use a different dataset and different aesthetics than the one we provided when we initialised the plot, so we can show our prediction that goes beyond the data.\nIf we look at what the model predicts for belayers with no climbing experience, it’s not particularly unusual. The reaction time is longer, though notice there are four individuals in the top left above the line who have more experience but also seem to have longer reaction times than newbies. The model doesn’t do a very good job predicting values for these belayers.\nNow let’s look at very experienced belayers. The reaction continues going down, however as we get to about 15 years of experience, the model starts predicting negative reaction times.\nThis, of course, makes no sense. It turns out this the convenient feature of being able to easily extend the line once we know it’s starting point and the direction is also the downfall of linear models - the line can go on forever and will inevitably predict nonsense if the linear model is not the appropriate model.\nRobust models are also - if not more - susceptible. They down-weigh scores with high residuals, especially scores at the tails of asymmetric distributions. The robust parameter estimate is therefore very good at describing what is happening at the centre of the distribution and make predictions for these scores, but it cannot describe or make predictions for individuals at the tails. That doesn’t mean robust models are useless. We just need be clear about what our intentions are and what we’re hoping to get out of the model. If the goal is to summarise the “typical individual” and we don’t particularly care about what’s happening at the tails, robust models might be just the solution we need.\nIf, however, we hope to be able to make conclusions about the whole distribution, we must take a different approach.",
    "crumbs": [
      "Generalised Linear Models"
    ]
  },
  {
    "objectID": "01_gzlms.html#introduction-to-gzlm",
    "href": "01_gzlms.html#introduction-to-gzlm",
    "title": "Generalised Linear Models",
    "section": "Introduction to GzLM",
    "text": "Introduction to GzLM\nGzLM are useful and versatile, but we shouldn’t just think about them as a “fix” for GLM models that don’t meet the assumptions. When it comes to data analysis that involves confirmatory hypothesis testing with p-values, it’s generally a bad idea to base key analytic decisions on something we’ve discovered in the data because doing so invalidates the p-values derived from our models. In other words, a good analytic pipeline should not take the form of (1) fit an OLS model (2) discover violated assumptions (3) fit GzLM to fix the problems.\nInstead, we should think about the data generating process when we are planning the analyses, or, better yet, before we even start data collection. Considering the variables we’re aiming to collect, what might the distributions look like? Is normal distribution a reasonable expectation? Is variance that doesn’t change at different values of the predictors a reasonable expectation? More often than not, the answer to the latter two questions is no.\n\nHow is GzLM different to GLM?\nGLM uses Ordinary Least Squares (OLS) estimation to fit models. The goal of OLS is to find the values of \\(\\beta_0\\), \\(\\beta_1\\), \\(\\beta_2\\) … so that the sum of squared errors (SSE) is as small is it can be given the data provided. Consider Figure 1 : if we were to measure the distance of each point from the line (i.e. the residual), square each distance and then sum all of them together, we’d get an SSE. For the model depicted in Figure 1, the line is the most optimal line that gives the smallest possible SSE.\nThe process is a little different for robust models using M-type estimation wherein the cases with the largest residuals get itteratively down-weighted until an optimal line is found, but the starting point is the result of OLS estimation.\n\nMaximum Likelihood estimation\nGzLM use Maximum Likelihood Estimation (ML)2. ML aims to find an optimal way to fit a given distribution to the data. It searches for the values of the the parameter estimates where a given assumed distribution is the most likely. In other words, where the likelihood of that distribution is at its maximum.\n\n\nConditional distributions\nWhat are we assuming the distribution of?\nWe know that OLS makes assumptions about the shape of errors in the population model - that is, it assumes they are normally distributed. Various guides will sometimes claim that we need to be checking a so called “response distribution”, which is just another word for the outcome. This is not quite right.\nML estimation makes assumptions about the conditional distribution of the outcome. Say that we’re trying to model the relationship between X and Y where\n\\[\nY_i = \\beta_0 + \\beta_1 X_i\n\\]\nIf we model this as a Gaussian model - that is, a model assuming a normal conditional distribution - we’re assuming that that the outcome Y is normally distribution at any value of X. As a formula, we would write:\n\\[\nP(Y|X) \\sim N(\\mu, \\sigma^2)\n\\]\nThat is, any Y value given any X values comes from a normal distribution with a mean \\(\\mu\\) and variance \\(\\sigma^2\\) .\nThe nice thing about GzLMs is that we can just relax this assumption if a different distribution is more appropriate.\nFor example here:\n\\[\nP(Y|X) \\sim \\Gamma(\\alpha, \\theta)\n\\]\nwe’re saying that the conditional distribution of Y given X is a Gamma distribution with a shape \\(\\alpha\\) and scale \\(\\theta\\) . More on this in section Modelling Skewness.\nThis distinction between the distribution of the outcome variable and the conditional distribution of the outcome variable is important. Similar to OLS, if we check the distribution of the outcome, it often will resemble the conditional distribution but this not a given - the outcome distribution will be composed of the many conditional distributions at various levels of the predictor(s) and there is no guarantee that the shape of all of these distributions will resemble the one we’re modelling when combined into the outcome variable.\nHave a look at Figure 6 . Hopefully you’ll agree that this is not a normal distribution:\n\n\n\n\n\n\n\n\nFigure 6\n\n\n\n\n\nHowever, if we were do decompose it, we’d find that the distribution in Figure 6 is actually built out of many normal distributions with different means:\n\n\n\n\n\n\n\n\nFigure 7\n\n\n\n\n\nTherefore checking the distribution of the outcome itself might be a good starting point, but it can lead us astray, especially if the conditional distribution substantially varies in parameters.\n\n\nMean-variance relationship\nIn GLM, we assume a constant variance of errors. That is, regardless of the predicted value, the spread of errors remains the same - this is homoscedasticity. Its violation, as we saw in Figure 4 is called heteroscedasticity.\nM-type robust estimators attempt to fix the impact of heteroscedasticity by (1) down-weighting cases with extreme residuals and (2) using an alternative estimator for the standard errors. Either way, heteroscedasticity is seen as some nuisance to be fixed.\nOn the other hand, GzLM can model various forms of heteroscedasticty explicitly and build these changes in variance into predictions. Different conditional distributions make different assumptions about the mean-variance relationship. For example, Gamma models assume a quadratic relationship:\n\\[\nV(Y) = E(Y)^2\n\\]\ni.e. in a given conditional distribution, the variance of scores will be equal to the squared expected3 value. Alternatively, the Poisson distribution can model a situation where the expected value is equal to the variance.\n\\[\nV(Y) = E(Y)\n\\]\nWe’ll cover these situations in more detail in the upcoming weeks. The bottom line is that GzLM offers a lot more flexibility than GLM, which can be useful in a variety of applied scenarios. So before we get too bogged down in terminology, let’s fit one more bad model to get the hang of the coding, and then we’ll finally move on to modelling tackling out hypotheses properly by choosing a more appropriate modelling approach.\n\n\n\nFitting GzLM in R\nSo let’s fit our model. We’re still going to (wrongly) assume the normal conditional distribution for our outcome, but this time we’ll fit the model using maximum likelihood estimation instead of OLS.\n\n1belay_glm &lt;- glm(\n2  reaction_time ~ assisted_break + climbing_exp + distracted + fall_m,\n3  family = gaussian(link = \"identity\"),\n4  data = belay_tib\n)\n\n\n1\n\nUse the glm() function instead of lm() . Store into an object belay_glm\n\n2\n\nSpecify the formula - same as before.\n\n3\n\nSpecify the family and the link function (see below)\n\n4\n\nSpecify the dataset - same as before\n\n\n\n\nThe main difference from the OLS model or the robust model is this line: family = gaussian(link = \"identity\") . Here, we’re telling R to assume normal conditional distribution (i.e. gaussian). We’re also asking R not to transform the variables in any way and model the relationship as linear directly (`link = \"identity\"). We’ll talk about what exactly this means in the upcoming sections but for now you just need to understand that the link = \"identity\" ensures that the parameter estimates we get out of the model can be interpreted as we’re used to, as a linear increase in the outcome expected with an increase of one unit in the predictor.\nWe can run the model checks as normal - the output is the same as before and can be interpreted as such, so there’s no need to repeat it here.\n\nbelay_glm |&gt; \n1  check_model()\n\nbelay_glm |&gt; \n2  performance()\n\nbelay_glm |&gt; \n3  test_wald()\n\n\n1\n\nCheck model assumptions\n\n2\n\nOverall fit statistics\n\n3\n\nTest of model fit\n\n\n\n\nThe parameter estimates will also be identical. The ML estimation is an algorithmic process with several steps, in which the model tries out different values before converging on ones with the maximum likelihood given the data. However, with Gaussian models, this algorithm converges on the exact same parameter estimates as OLS right after the first step.\nWe’ve not actually produced the OLS estimates before, so let’s compare them to the ML estimates side by side:\n\nOLS (GLM) estimatesML (GzLM) estimates\n\n\n\nbelay_lm |&gt; \n  parameters() |&gt; \n  display()\n\n\n\n\n\n\n\n\n\n\n\n\nParameter\nCoefficient\nSE\n95% CI\nt(147)\np\n\n\n\n\n(Intercept)\n732.93\n51.00\n(632.14, 833.73)\n14.37\n&lt; .001\n\n\nassisted break\n-33.03\n17.07\n(-66.77, 0.71)\n-1.93\n0.055\n\n\nclimbing exp\n-59.96\n5.80\n(-71.42, -48.49)\n-10.33\n&lt; .001\n\n\ndistracted\n70.29\n16.90\n(36.89, 103.69)\n4.16\n&lt; .001\n\n\nfall m\n77.54\n20.86\n(36.32, 118.77)\n3.72\n&lt; .001\n\n\n\n\n\n\n\n\nbelay_glm |&gt; \n  parameters() |&gt; \n  display()\n\n\n\n\n\n\n\n\n\n\n\n\nParameter\nCoefficient\nSE\n95% CI\nt(147)\np\n\n\n\n\n(Intercept)\n732.93\n51.00\n(632.97, 832.90)\n14.37\n&lt; .001\n\n\nassisted break\n-33.03\n17.07\n(-66.49, 0.43)\n-1.93\n0.053\n\n\nclimbing exp\n-59.96\n5.80\n(-71.33, -48.58)\n-10.33\n&lt; .001\n\n\ndistracted\n70.29\n16.90\n(37.17, 103.42)\n4.16\n&lt; .001\n\n\nfall m\n77.54\n20.86\n(36.65, 118.43)\n3.72\n&lt; .001\n\n\n\n\n\n\n\n\nAlthough the estimates themselves are the same, the confidence intervals and the p-values are not. This is deliberate. When we fit OLS models, we use the critical t statistic4 based on the residual degrees of freedom to construct the CIs. The test statistic is then calculated by dividing the parameter estimate by its standard error, and this is compared against a theoretical t distribution to calculate the p-value.\nWhen we fitted the GzLM, we explicitly told R to assume a normal/Gaussian distribution. So the model takes us for our word, and instead of using the t distribution, it compares the test statistic against a normal distribution. Likewise, the CIs are constructed using the critical Z value, not the critical t value. The parameters function is quite clever in that it automatically detects what kind of model we fitted and gives us the result based on that.",
    "crumbs": [
      "Generalised Linear Models"
    ]
  },
  {
    "objectID": "01_gzlms.html#conclusion",
    "href": "01_gzlms.html#conclusion",
    "title": "Generalised Linear Models",
    "section": "Conclusion",
    "text": "Conclusion\nOf course, if we were to actually run any of the model checks, we’d still find that the model is fundamentally flawed. Regardless of the approach, a normal distribution is not the appropriate distribution to be assuming here. If we fit a robust model, the predictions we’re generating are only useful for the middle of the distribution, while the predictions at the tails breach the realm of science-fiction with reality-bending reaction times. If we want to create a useful model of the reality, we need to change the assumptions we’re making about the data-generating process.\n\nWelcome to the family\nThe General Linear Model encompasses many types of models that use OLS estimation (like the t-test, ANOVA, regression and others). The Generalised Linear Model takes this even further and can model various forms of the Exponential Family . This may seem counter-intuitive because when we say “Exponential” we often imagine a line that grows or descends steeply (or “exponentially”), but this distribution family in an overarching group of distributions that come in many shapes and sizes, including:\n\nBernoulli distribution (often assumed in logistic regression)\nChi-squared distribution\nDirichlet distribution\nExponential distribution\nGamma distribution\nNormal distribution (yes, even normal distribution)\nPoisson distribution\n\nand others. We’re going to learn about some of these in the coming weeks.",
    "crumbs": [
      "Generalised Linear Models"
    ]
  },
  {
    "objectID": "01_gzlms.html#exercises",
    "href": "01_gzlms.html#exercises",
    "title": "Generalised Linear Models",
    "section": "Exercises",
    "text": "Exercises\n\nWhat does this code do?\n\n\n\n\n\n\nHere’s all the code we have written in this section. Can you remember what each line of each codechunk does? Are there any codechunks that you struggle to make sense of? Make sure to revisit the section in which it is used and take notes.\n\n\n\n\nlibrary(easystats) \nlibrary(tidyverse) \n\nbelay_tib &lt;- here::here(\"data/climbing_data.csv\") |&gt; \n  readr::read_csv() \n\n\nbelay_tib |&gt; \n  describe_distribution(select = -subj_id) |&gt; \n  display() \n\n\nbelay_tib |&gt; \n  ggplot2::ggplot(data = _, aes(x = climbing_exp, y = reaction_time)) + \n  geom_point(alpha = 0.7, colour = \"yellowgreen\") + \n  stat_smooth(method = \"lm\", colour = \"steelblue\", fill = \"steelblue\") + \n  coord_cartesian(xlim = c(0, 10), ylim = c(0, 1030.5)) + \n  labs(x = \"Belayer's climbing experience (in years)\", y = \"Reaction time (ms) to break the fall\") + \n  theme_light() \n\n\nbelay_tib |&gt; \n  ggplot2::ggplot(data = _, aes(x = reaction_time)) + \n  geom_density(colour = \"steelblue\", fill = \"steelblue\", alpha = 0.1) + \n  labs(x = \"Reaction time (ms) to break the fall\", y = \"Density\") + \n  theme_light()\n\n\nbelay_lm |&gt; check_model()\n\n\nbelay_lm |&gt; \n  performance() |&gt; \n  display()\n\n\nbelay_lm |&gt; \n  test_wald() |&gt; \n  display()\n\n\nbelay_rob |&gt; \n  parameters() |&gt; \n  display()\n\n\nprediction_tib &lt;- tibble::tibble(\n  climbing_exp = 0:20,\n  assisted_break = 0,\n  distracted = 0,\n  fall_m = 1.82\n)\n\n\npredict(belay_rob, prediction_tib)\n\n\nbelay_glm |&gt; \n  check_model()  \n\nbelay_glm |&gt; \n  performance()  \n\nbelay_glm |&gt; \n  test_wald() \n\n\nbelay_glm |&gt; \n  parameters() |&gt; \n  display()\n\n\nbelay_tib |&gt; \n  ggplot2::ggplot(data = _, aes(x = factor(assisted_break), y = reaction_time)) +\n  geom_point(alpha = 0.7, colour = \"yellowgreen\", position = position_jitter(width = 0.1)) + \n  stat_summary(fun.data = \"mean_cl_normal\") + \n  coord_cartesian(ylim = c(0, 1030.5)) + \n  labs(x = \"Did the belayer used an assisted breaking device\", y = \"Reaction time (ms) to break the fall\") + \n  theme_light()",
    "crumbs": [
      "Generalised Linear Models"
    ]
  },
  {
    "objectID": "01_gzlms.html#footnotes",
    "href": "01_gzlms.html#footnotes",
    "title": "Generalised Linear Models",
    "section": "",
    "text": "A “belayer” is the person on the ground, managing the rope and ensuring the climber on the wall is safe.↩︎\nUnhelpfully, the ML abbreviation is also reserved for “Machine Learning”, so just be aware of this if you’re using any external resources.↩︎\nYou could substitute the term “expected” with “predicted”. The only difference is that we tend to use “predicted” when talking about a single value, and “expected” when talking about a whole distribution, but for all intents and purposes, they are the same.↩︎\nThis is not the same as the t statistic that we see in the tables.↩︎",
    "crumbs": [
      "Generalised Linear Models"
    ]
  }
]